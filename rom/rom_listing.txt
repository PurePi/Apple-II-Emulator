                     * listing for rom.asm generated on 2019-1-20 at 11:30:03

FA00:              1         ORG $FA00       ; we know this code will be loaded into address $FA00, and the reset vector points here
FA00:              2 
FA00:              3 ACC     EQU $00         ; zeropage addresses used for storing important data
FA00:              4 XREG    EQU $01
FA00:              5 YREG    EQU $02
FA00:              6 STATUS  EQU #03
FA00:              7 SPTR    EQU $04
FA00:              8 COUTLO  EQU $05         ; for storing low/high byte of row address
FA00:              9 COUTHI  EQU $06
FA00:             10 PAGE1Y  EQU $07         ; keep track of Y position on first page
FA00:             11 PAGE2Y  EQU $08         ; keep track of Y position on second page
FA00:             12 
FA00:  4C 36 FA   13         JMP kbdex       ; jump to an example
FA03:             14 
FA03:             15 *       writing to screen example
FA03:             16 
FA03:             17 ODDROWL EQU $00         ; low byte of odd-numbered rows (first row is row 1 in this example)
FA03:             18 EVNROWL EQU $80
FA03:             19 ROW1H   EQU $04         ; high byte of rows 1 and 2
FA03:             20 ROW3H   EQU $05         ; high byte of rows 3 and 4
FA03:             21 PG2H    EQU $08         ; high byte of screen page 2 (first row)
FA03:             22 
FA03:  A9 21      23 printex LDA #$21        ; starting ascii code
FA05:  A0 00      24         LDY #$00        ; index in row to place char
FA07:             25 
FA07:  A2 04      26         LDX #ROW1H      ; put address of row into COUTLO, COUTHI
FA09:  86 06      27         STX COUTHI
FA0B:  A2 00      28         LDX #ODDROWL
FA0D:  86 05      29         STX COUTLO
FA0F:  20 25 FA   30         JSR outloop
FA12:             31 
FA12:  A2 80      32         LDX #EVNROWL    ; adjust row base address, row 2 is even but page is the same so COUTHI can stay
FA14:  86 05      33         STX COUTLO
FA16:  20 25 FA   34         JSR outloop
FA19:             35 
FA19:  A2 05      36         LDX #ROW3H      ; adjust row base address, page also changes this time
FA1B:  86 06      37         STX COUTHI
FA1D:  A2 00      38         LDX #ODDROWL
FA1F:  86 05      39         STX COUTLO
FA21:  20 25 FA   40         JSR outloop
FA24:  02         41 done    HCF             ; halt and catch fire
FA25:             42 
FA25:  91 05      43 outloop STA (COUTLO),Y  ; store character at row base address + Y
FA27:  C9 7F      44         CMP #$7F
FA29:  F0 F9      45         BEQ done        ; done when we reach last character
FA2B:  69 01      46         ADC #$01
FA2D:  C8         47         INY
FA2E:  C0 28      48         CPY #$28
FA30:  D0 F3      49         BNE outloop
FA32:  A0 00      50         LDY #$00
FA34:  18         51         CLC             ; CPY sets carry if Y >= data ($28 = $28 in this case)
FA35:  60         52         RTS
FA36:             53 
FA36:             54 *       print keyboard input onto screen example
FA36:             55 
FA36:  A0 00      56 kbdex   LDY #$00        ; set up screen output the same way as above example
FA38:             57 
FA38:  A2 04      58         LDX #ROW1H
FA3A:  86 06      59         STX COUTHI
FA3C:  A2 00      60         LDX #ODDROWL
FA3E:  86 05      61         STX COUTLO
FA40:             62 
FA40:  2C 00 C0   63 scanin  BIT $C000       ; check if highest bit is on (input received flag)
FA43:  30 03      64         BMI input
FA45:  4C 40 FA   65         JMP scanin
FA48:             66 
FA48:  AD 00 C0   67 input   LDA $C000       ; get that input, remove highest bit to get ascii code
FA4B:  29 7F      68         AND #$7F
FA4D:  8D 10 C0   69         STA $C010       ; reference $C010-$C01F to clear input flag on $C000-$C00F
FA50:  C9 09      70         CMP #$09        ; tab to switch pages
FA52:  F0 0E      71         BEQ swtchpg
FA54:  18         72         CLC
FA55:  91 05      73         STA (COUTLO),Y
FA57:  C8         74         INY
FA58:  C0 28      75         CPY #$28
FA5A:  D0 E4      76         BNE scanin
FA5C:  A0 00      77         LDY #$00        ; just wrap around same line
FA5E:  18         78         CLC             ; CPY sets carry if Y >= data ($28 = $28 in this case)
FA5F:  4C 40 FA   79         JMP scanin
FA62:             80 
FA62:  A6 06      81 swtchpg LDX COUTHI
FA64:  E0 08      82         CPX #PG2H       ; if high byte of row is $08, we're currently on second page so we switch to the first
FA66:  F0 0E      83         BEQ firstpg
FA68:  8D 55 C0   84 secndpg STA $C055       ; switch to second page
FA6B:  84 07      85         STY PAGE1Y
FA6D:  A4 08      86         LDY PAGE2Y
FA6F:  A2 08      87         LDX #PG2H
FA71:  86 06      88         STX COUTHI
FA73:  4C 40 FA   89         JMP scanin
FA76:  8D 54 C0   90 firstpg STA $C054       ; switch to first page
FA79:  84 08      91         STY PAGE2Y
FA7B:  A4 07      92         LDY PAGE1Y
FA7D:  A2 04      93         LDX #ROW1H
FA7F:  86 06      94         STX COUTHI
FA81:  4C 40 FA   95         JMP scanin
FA84:             96 
FA84:             97 *       peripheral card PROM example
FA84:             98 ***     NOT YET IMPLEMENTED
FA84:             99 
FA84:  20 A2 FA  100         JSR SAVE        ; save all registers
FA87:  78        101         SEI             ; disable interrupts
FA88:  BA        102         TSX             ; stack pointer points to page of return address that JSR just pushed, slot n is in the form of $Cn
FA89:  BD 00 01  103         LDA $0100,X     ; load that page number into A
FA8C:  8D F8 07  104         STA $07F8       ; $7F8 is designated to keep page number of active card
FA8F:  29 0F     105         AND #$0F
FA91:  0A        106         ASL A
FA92:  0A        107         ASL A
FA93:  0A        108         ASL A
FA94:  0A        109         ASL A
FA95:  AA        110         TAX             ; X now has slot number in the form of $n0
FA96:  BD 80 C0  111         LDA $C080,X     ; access byte 0 of your card's scratchpad
FA99:  BD 81 C0  112         LDA $C081,X     ; access byte 1 of your card's scratchpad (up to $C08F,X for byte 15)
FA9C:  AD FF CF  113         LDA $CFFF       ; request access to expansion rom by referencing $CFFF
FA9F:  20 00 C8  114         JSR $C800       ; can now access your card's expansion rom ($C800-$CFFF)
FAA2:            115 
FAA2:            116 *       ROM subroutines
FAA2:            117 
FAA2:  85 00     118 SAVE    STA ACC
FAA4:  86 01     119         STX XREG
FAA6:  84 02     120         STY YREG
FAA8:  08        121         PHP
FAA9:  68        122         PLA
FAAA:  85 03     123         STA STATUS
FAAC:  BA        124         TSX
FAAD:  86 04     125         STX SPTR
FAAF:  D8        126         CLD
FAB0:  60        127         RTS
FAB1:  A5 03     128 RESTORE LDA STATUS
FAB3:  48        129         PHA
FAB4:  A5 00     130         LDA ACC
FAB6:  A6 01     131         LDX XREG
FAB8:  A4 02     132         LDY YREG
FABA:  28        133         PLP
FABB:  60        134         RTS

                     * Assembled 188 bytes