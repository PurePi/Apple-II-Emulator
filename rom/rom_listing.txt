                     * listing for rom.asm generated on 2019-1-28 at 00:05:39

FA00:              1         ORG $FA00       ; we know this code will be loaded into address $FA00, and the reset vector points here
FA00:              2 
FA00:              3 ACC     EQU $00         ; zeropage addresses used for storing important data
FA00:              4 XREG    EQU $01
FA00:              5 YREG    EQU $02
FA00:              6 STATUS  EQU #03
FA00:              7 SPTR    EQU $04
FA00:              8 COUTLO  EQU $05         ; for storing low/high byte of row address
FA00:              9 COUTHI  EQU $06
FA00:             10 PAGE1Y  EQU $07         ; keep track of Y position on first page
FA00:             11 PAGE2Y  EQU $08         ; keep track of Y position on second page
FA00:             12 
FA00:  4C A3 FA   13         JMP hires       ; jump to an example
FA03:             14 
FA03:             15 *       writing to screen example
FA03:             16 
FA03:             17 ODDROWL EQU $00         ; low byte of odd-numbered rows (first row is row 1 in this example)
FA03:             18 EVNROWL EQU $80
FA03:             19 ROW1H   EQU $04         ; high byte of rows 1 and 2
FA03:             20 ROW3H   EQU $05         ; high byte of rows 3 and 4
FA03:             21 PG2H    EQU $08         ; high byte of screen page 2 (first row)
FA03:             22 
FA03:  A9 A0      23 print   LDA #$A0        ; start at first normal character
FA05:  A0 00      24         LDY #$00        ; index in row to place char
FA07:  A2 04      25         LDX #ROW1H      ; put address of row into COUTLO, COUTHI
FA09:  86 06      26         STX COUTHI
FA0B:  A2 00      27         LDX #ODDROWL
FA0D:  86 05      28         STX COUTLO
FA0F:  20 25 FA   29         JSR outloop
FA12:  A2 80      30         LDX #EVNROWL    ; adjust row base address, row 2 is even but page is the same so COUTHI can stay
FA14:  86 05      31         STX COUTLO
FA16:  20 25 FA   32         JSR outloop
FA19:  A2 05      33         LDX #ROW3H      ; adjust row base address, page also changes this time
FA1B:  86 06      34         STX COUTHI
FA1D:  A2 00      35         LDX #ODDROWL
FA1F:  86 05      36         STX COUTLO
FA21:  20 25 FA   37         JSR outloop
FA24:  02         38 done    HCF             ; halt and catch fire
FA25:  91 05      39 outloop STA (COUTLO),Y  ; store character at row base address + Y
FA27:  C9 DF      40         CMP #$DF
FA29:  F0 F9      41         BEQ done        ; done when we reach last character
FA2B:  69 01      42         ADC #$01
FA2D:  C8         43         INY
FA2E:  C0 28      44         CPY #$28
FA30:  D0 F3      45         BNE outloop
FA32:  A0 00      46         LDY #$00
FA34:  18         47         CLC             ; CPY sets carry if Y >= data ($28 = $28 in this case)
FA35:  60         48         RTS
FA36:             49 
FA36:             50 *       print keyboard input onto screen example
FA36:             51 
FA36:  A0 00      52 kbd     LDY #$00        ; set up screen output the same way as above example
FA38:  A2 04      53         LDX #ROW1H
FA3A:  86 06      54         STX COUTHI
FA3C:  A2 00      55         LDX #ODDROWL
FA3E:  86 05      56         STX COUTLO
FA40:  18         57 undersc CLC
FA41:  A9 5F      58         LDA #$5F
FA43:  91 05      59         STA (COUTLO),Y
FA45:  2C 00 C0   60 scan    BIT $C000       ; check if highest bit is on (input received flag)
FA48:  30 03      61         BMI input
FA4A:  4C 45 FA   62         JMP scan
FA4D:  AD 00 C0   63 input   LDA $C000       ; get that input, keep highest bit to display normally
FA50:  8D 10 C0   64         STA $C010       ; reference $C010-$C01F to clear input flag on $C000-$C00F
FA53:  C9 8D      65         CMP #$8D        ; enter to switch pages
FA55:  F0 0D      66         BEQ swtchpg
FA57:  18         67         CLC
FA58:  91 05      68         STA (COUTLO),Y
FA5A:  C8         69         INY
FA5B:  C0 28      70         CPY #$28
FA5D:  D0 E1      71         BNE undersc
FA5F:  A0 00      72         LDY #$00        ; just wrap around same line
FA61:  4C 40 FA   73         JMP undersc
FA64:  A6 06      74 swtchpg LDX COUTHI
FA66:  E0 08      75         CPX #PG2H       ; if high byte of row is $08, we're currently on second page so we switch to the first
FA68:  F0 0E      76         BEQ firstpg     ; otherwise this branch doesn't happen and it continues to switch to second page
FA6A:  8D 55 C0   77 secndpg STA $C055       ; switch to second page
FA6D:  84 07      78         STY PAGE1Y      ; save Y offset used in first page
FA6F:  A4 08      79         LDY PAGE2Y      ; recall the offset used in second page
FA71:  A2 08      80         LDX #PG2H       ; switch base address of row to that of the second page
FA73:  86 06      81         STX COUTHI
FA75:  4C 40 FA   82         JMP undersc
FA78:  8D 54 C0   83 firstpg STA $C054       ; switch to first page
FA7B:  84 08      84         STY PAGE2Y
FA7D:  A4 07      85         LDY PAGE1Y
FA7F:  A2 04      86         LDX #ROW1H
FA81:  86 06      87         STX COUTHI
FA83:  4C 40 FA   88         JMP undersc
FA86:             89 
FA86:  A0 00      90 lores   LDY #$00
FA88:  A2 04      91         LDX #ROW1H
FA8A:  86 06      92         STX COUTHI
FA8C:  A2 00      93         LDX #ODDROWL
FA8E:  86 05      94         STX COUTLO
FA90:  A9 00      95         LDA #$00
FA92:  8D 50 C0   96         STA $C050       ; switch to graphics mode
FA95:  8D 56 C0   97         STA $C056       ; set lo-res
FA98:  18         98 loloop  CLC
FA99:  91 05      99         STA (COUTLO),Y
FA9B:  69 01     100         ADC #$01
FA9D:  C8        101         INY
FA9E:  C9 28     102         CMP #$28
FAA0:  D0 F6     103         BNE loloop
FAA2:  02        104         HCF
FAA3:            105 
FAA3:            106 HIPG1L  EQU $00
FAA3:            107 HIPG1H  EQU $20
FAA3:            108 
FAA3:  A0 00     109 hires   LDY #$00
FAA5:  A2 20     110         LDX #HIPG1H
FAA7:  86 06     111         STX COUTHI
FAA9:  A2 00     112         LDX #HIPG1L
FAAB:  86 05     113         STX COUTLO
FAAD:  8D 50 C0  114         STA $C050       ; switch to graphics mode (hi res already set from cold start)
FAB0:  91 05     115         STA (COUTLO),Y  ; just placing a few random colors
FAB2:  A9 12     116         LDA #%00010010
FAB4:  C8        117         INY
FAB5:  91 05     118         STA (COUTLO),Y
FAB7:  A9 01     119         LDA #%00000001  ; MSb is palette, then pairs from LSb determine color
FAB9:  C8        120         INY
FABA:  91 05     121         STA (COUTLO),Y
FABC:  A9 27     122         LDA #%00100111  ; palette = 0, %00 = black, %01 = green, %10 = violet, %11 = white
FABE:  C8        123         INY
FABF:  91 05     124         STA (COUTLO),Y
FAC1:  A9 09     125         LDA #%00001001  ; bit 6 is ignored
FAC3:  C8        126         INY
FAC4:  91 05     127         STA (COUTLO),Y
FAC6:  A9 3F     128         LDA #%00111111  ; note that LSb is leftmost pixel
FAC8:  C8        129         INY
FAC9:  91 05     130         STA (COUTLO),Y
FACB:  A9 3B     131         LDA #%00111011
FACD:  C8        132         INY
FACE:  91 05     133         STA (COUTLO),Y
FAD0:  A9 A5     134         LDA #%10100101  ; palette = 1, %00 = black, %01 = orange, %10 = blue, %11 = white
FAD2:  C8        135         INY
FAD3:  91 05     136         STA (COUTLO),Y
FAD5:  A9 B6     137         LDA #%10110110
FAD7:  C8        138         INY
FAD8:  91 05     139         STA (COUTLO),Y
FADA:  A9 8C     140         LDA #%10001100
FADC:  C8        141         INY
FADD:  91 05     142         STA (COUTLO),Y
FADF:  A9 A1     143         LDA #%10100001
FAE1:  C8        144         INY
FAE2:  91 05     145         STA (COUTLO),Y
FAE4:  8D 53 C0  146         STA $C053       ; enable mixed mode
FAE7:  A9 C1     147         LDA #$C1        ; place an 'A' at the first location for text captions
FAE9:  8D 50 06  148         STA $0650
FAEC:  02        149         HCF
FAED:            150 
FAED:            151 *       using peripheral cards in slot 1 and 4 example (both contain the same card)
FAED:            152 
FAED:  8D 90 C0  153 card    STA $C090       ; first need to reference slot 1's GPIO space to select it
FAF0:  20 00 C1  154         JSR $C100       ; jump to its PROM
FAF3:  8D C4 C0  155         STA $C0C4       ; now let's use slot 4 (can reference any byte in its GPIO space, not only byte 0)
FAF6:  20 00 C4  156         JSR $C400
FAF9:  8D 90 C0  157         STA $C090       ; and slot 1 again (remember that this first reference does not trigger its callback, only enables it)
FAFC:  20 00 C1  158         JSR $C100
FAFF:  02        159         HCF
FB00:            160 
FB00:            161 *       ROM subroutines
FB00:            162 
FB00:  85 00     163 SAVE    STA ACC
FB02:  86 01     164         STX XREG
FB04:  84 02     165         STY YREG
FB06:  08        166         PHP
FB07:  68        167         PLA
FB08:  85 03     168         STA STATUS
FB0A:  BA        169         TSX
FB0B:  86 04     170         STX SPTR
FB0D:  D8        171         CLD
FB0E:  60        172         RTS
FB0F:  A5 03     173 RESTORE LDA STATUS
FB11:  48        174         PHA
FB12:  A5 00     175         LDA ACC
FB14:  A6 01     176         LDX XREG
FB16:  A4 02     177         LDY YREG
FB18:  28        178         PLP
FB19:  60        179         RTS

                     * Assembled 282 bytes